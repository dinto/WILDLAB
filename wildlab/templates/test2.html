// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © DINTO_DAVI

//@version=5
indicator("SuperNovaLux",shorttitle="SuperNova",overlay=true,max_bars_back=1000,max_lines_count=500,max_labels_count=500, max_boxes_count = 500 )



length4 = input.int(14)
k      = input.float(1.,'Slope',minval=0,step=.1)
method = input.string('Atr','Slope Calculation Method',
  options=['Atr','Stdev','Linreg'])
show   = input(false,'Show Only Confirmed Breakouts')
upper = 0.,lower = 0.
slope_ph = 0.,slope_pl = 0.
src = close
n = bar_index
ph = ta.pivothigh(length4,length4)
pl = ta.pivotlow(length4,length4)
slope = switch method
    'Atr'      => ta.atr(length4)/length4*k
    'Stdev'    => ta.stdev(src,length4)/length4*k
    'Linreg'   => math.abs(ta.sma(src*bar_index,length4)-ta.sma(src,length4)*ta.sma(bar_index,length4))/ta.variance(n,length4)/2*k

slope_ph := ph ? slope : slope_ph[1]
slope_pl := pl ? slope : slope_pl[1]

upper := ph ? ph : upper[1] - slope_ph
lower := pl ? pl : lower[1] + slope_pl
single_upper = 0
single_lower = 0
single_upper := src[length4] > upper ? 0 : ph ? 1 : single_upper[1]
single_lower := src[length4] < lower ? 0 : pl ? 1 : single_lower[1]
upper_breakout = single_upper[1] and src[length4] > upper and (show ? src > src[length4] : 1)
lower_breakout = single_lower[1] and src[length4] < lower and (show ? src < src[length4] : 1)
plotshape(upper_breakout ? low[length4] : na,"Upper Break",shape.labelup,location.absolute,#26a69a,-length4,text="B",textcolor=color.white,size=size.tiny)
plotshape(lower_breakout ? high[length4] : na,"Lower Break",shape.labeldown,location.absolute,#ef5350,-length4,text="B",textcolor=color.white,size=size.tiny)
var line up_l = na
var line dn_l = na
var label recent_up_break = na
var label recent_dn_break = na

if ph[1]
    line.delete(up_l[1])
    label.delete(recent_up_break[1])
    
    up_l := line.new(n-length4-1,ph[1],n-length4,upper,color=#26a69a,
      extend=extend.right,style=line.style_dashed)
if pl[1]
    line.delete(dn_l[1])
    label.delete(recent_dn_break[1])
    
    dn_l := line.new(n-length4-1,pl[1],n-length4,lower,color=#ef5350,
      extend=extend.right,style=line.style_dashed)

if ta.crossover(src,upper-slope_ph*length4)
    label.delete(recent_up_break[1])
    recent_up_break := label.new(n,low,'B',color=#26a69a,
      textcolor=color.white,style=label.style_label_up,size=size.small)

if ta.crossunder(src,lower+slope_pl*length4)
    label.delete(recent_dn_break[1])
    recent_dn_break := label.new(n,high,'B',color=#ef5350,
      textcolor=color.white,style=label.style_label_down,size=size.small)
    
//----
plot(upper,'Upper',color = ph ? na : #26a69a,offset=-length4)
plot(lower,'Lower',color = pl ? na : #ef5350,offset=-length4)

alertcondition(ta.crossover(src,upper-slope_ph*length4),'Upper Breakout','Price broke upper trendline')
alertcondition(ta.crossunder(src,lower+slope_pl*length4),'Lower Breakout','Price broke lower trendline')


length = input.float(500,'Window Size',maxval=500,minval=0)
h      = input.float(8.,'Bandwidth')
mult   = input.float(3.) 
srcnada    = input.source(close,'Source')


up_col = input.color(#39ff14,'Colors',inline='col')
dn_col = input.color(#ff1100,'',inline='col')
disclaimer = input(false, 'Hide Disclaimer')
//----
n1 = bar_index
var k1 = 2
var upper1 = array.new_line(0) 
var lower1 = array.new_line(0) 

lset(l,x1,y1,x2,y2,col)=>
    line.set_xy1(l,x1,y1)
    line.set_xy2(l,x2,y2)
    line.set_color(l,col)
    line.set_width(l,2)

if barstate.isfirst
    for i = 0 to length/k1-1
        array.push(upper1,line.new(na,na,na,na))
        array.push(lower1,line.new(na,na,na,na))
//----
line up = na
line dn = na
//----
cross_up = 0.
cross_dn = 0.
if barstate.islast
    y = array.new_float(0)
    
    sum_e = 0.
    for i = 0 to length-1
        sum = 0.
        sumw = 0.
        
        for j = 0 to length-1
            w = math.exp(-(math.pow(i-j,2)/(h*h*2)))
            sum += srcnada[j]*w
            sumw += w
        
        y2 = sum/sumw
        sum_e += math.abs(srcnada[i] - y2)
        array.push(y,y2)

    mae = sum_e/length*mult
    
    for i = 1 to length-1
        y2 = array.get(y,i)
        y1 = array.get(y,i-1)
        
        up := array.get(upper1,i/k1)
        dn := array.get(lower1,i/k1)
        
        lset(up,n-i+1,y1 + mae,n1-i,y2 + mae,up_col)
        lset(dn,n-i+1,y1 - mae,n1-i,y2 - mae,dn_col)
        
        if srcnada[i] > y1 + mae and srcnada[i+1] < y1 + mae
            label.new(n1-i,srcnada[i],'▼',color=#00000000,style=label.style_label_down,textcolor=dn_col,textalign=text.align_center)
        if srcnada[i] < y1 - mae and srcnada[i+1] > y1 - mae
            label.new(n1-i,srcnada[i],'▲',color=#00000000,style=label.style_label_up,textcolor=up_col,textalign=text.align_center)
    
    cross_up := array.get(y,0) + mae
    cross_dn := array.get(y,0) - mae

alertcondition(ta.crossover(srcnada,cross_up),'Down','Down')
alertcondition(ta.crossunder(srcnada,cross_dn),'Up','Up')

//----
var tb = table.new(position.top_right, 1, 1
  , bgcolor = #35202b)

if barstate.isfirst and not disclaimer
    table.cell(tb, 0, 0, 'Nadaraya-Watson Envelope [LUX] Repaints'
      , text_size = size.small
      , text_color = #cc2f3c)




len = input.int(20, minval=1, title="Length")
src5 = input(close, title="Source")
offset = input.int(title="Offset", defval=0, minval=-500, maxval=500)
out = ta.ema(src5, len)
plot(out, title="EMA20", color=color.blue, offset=offset)



len2 = input.int(55, minval=1, title="Length")
src2 = input(close, title="Source")
out4 = ta.ema(src2, len2)
plot(out4, title="EMA55", color=color.purple, offset=offset)

len1 = input.int(200, minval=1, title="Length")
src1 = input(close, title="Source")
out1 = ta.ema(src1, len1)
plot(out1, title="EMA200", color=color.red, offset=offset)

ma(source, length, type) =>
    switch type
        "SMA" => ta.sma(source, length)
        "EMA" => ta.ema(source, length)
        "SMMA (RMA)" => ta.rma(source, length)
        "WMA" => ta.wma(source, length)
        "VWMA" => ta.vwma(source, length)

typeMA = input.string(title = "Method", defval = "SMA", options=["SMA", "EMA", "SMMA (RMA)", "WMA", "VWMA"], group="Smoothing")
smoothingLength = input.int(title = "Length", defval = 5, minval = 1, maxval = 100, group="Smoothing")

smoothingLine = ma(out, smoothingLength, typeMA)
plot(smoothingLine, title="Smoothing Line", color=#f37f20, offset=offset, display=display.none)

start = input(0.02)
increment = input(0.02)
maximum = input(0.2, "Max Value")
out2 = ta.sar(start, increment, maximum)
plot(out2, "ParabolicSAR", style=plot.style_cross, color=#2962FF)










rsiLengthInput = input.int(14, minval=1, title="RSI Length", group="RSI Settings")
rsiSourceInput = input.source(close, "Source", group="RSI Settings")
maTypeInput = input.string("SMA", title="MA Type", options=["SMA", "Bollinger Bands", "EMA", "SMMA (RMA)", "WMA", "VWMA"], group="MA Settings")
maLengthInput = input.int(14, title="MA Length", group="MA Settings")
bbMultInput = input.float(2.0, minval=0.001, maxval=50, title="BB StdDev", group="MA Settings")

up1 = ta.rma(math.max(ta.change(rsiSourceInput), 0), rsiLengthInput)
down = ta.rma(-math.min(ta.change(rsiSourceInput), 0), rsiLengthInput)
rsi = down == 0 ? 100 : up1 == 0 ? 0 : 100 - (100 / (1 + up1 / down))
rsiMA = ma(rsi, maLengthInput, maTypeInput)
isBB = maTypeInput == "Bollinger Bands"

plot(rsi, "RSI", color= color.red )
//plot(rsiMA, "RSI-based MA", color=color.yellow)
rsiUpperBand = hline(70, "RSI Upper Band", color=#787B86)
hline(50, "RSI Middle Band", color=color.new(#787B86, 50))
rsiLowerBand = hline(30, "RSI Lower Band", color=#787B86)
fill(rsiUpperBand, rsiLowerBand, color=color.rgb(126, 87, 194, 90), title="RSI Background Fill")
bbUpperBand = plot(isBB ? rsiMA + ta.stdev(rsi, maLengthInput) * bbMultInput : na, title = "Upper Bollinger Band", color=color.green)
bbLowerBand = plot(isBB ? rsiMA - ta.stdev(rsi, maLengthInput) * bbMultInput : na, title = "Lower Bollinger Band", color=color.green)
fill(bbUpperBand, bbLowerBand, color= isBB ? color.new(color.green, 90) : na, title="Bollinger Bands Background Fill")
isgreen() => (rsi >= 20 and  rsi< 31)
isred() => rsi >= 70  
bgcolor(isgreen() ? color.rgb(178, 216, 179) : isred() ? color.rgb(255, 82, 82, 59) : na)



//supertrend 5,1
atrPeriod2 = input(5, "ATR Length")
factor2 = input.float(1, "Factor", step = 0.01)

[supertrend2, direction2] = ta.supertrend(factor2, atrPeriod2)

bodyMiddle2 = plot((open + close) / 2, display=display.none)
upTrend2 = plot(direction2 < 0 ? supertrend2 : na, "Up Trend", color = color.green, style=plot.style_linebr)
downTrend2 = plot(direction2 < 0? na : supertrend2, "Down Trend", color = color.red, style=plot.style_linebr)

fill(bodyMiddle2, upTrend2, color.new(color.green, 90), fillgaps=false)
fill(bodyMiddle2, downTrend2, color.new(color.red, 90), fillgaps=false)

//supertrend end 5,1

//supertrend 7,2.5
atrPeriod = input(7, "ATR Length")
factor = input.float(2.5, "Factor", step = 0.01)

[supertrend, direction] = ta.supertrend(factor, atrPeriod)

bodyMiddle = plot((open + close) / 2, display=display.none)
upTrend = plot(direction < 0 ? supertrend : na, "Up Trend", color = color.green, style=plot.style_linebr)
downTrend = plot(direction < 0? na : supertrend, "Down Trend", color = color.red, style=plot.style_linebr)

fill(bodyMiddle, upTrend, color.new(color.green, 90), fillgaps=false)
fill(bodyMiddle, downTrend, color.new(color.red, 90), fillgaps=false)

//supertrend end 7,2.5

//supertrend 10,3
atrPeriod1 = input(10, "ATR Length")
factor1 = input.float(3.0, "Factor", step = 0.01)

[supertrend1, direction1] = ta.supertrend(factor1, atrPeriod1)

bodyMiddle1 = plot((open + close) / 2, display=display.none)
upTrend1 = plot(direction1 < 0 ? supertrend1 : na, "Up Trend", color = color.green, style=plot.style_linebr)
downTrend1 = plot(direction1 < 0? na : supertrend1, "Down Trend", color = color.red, style=plot.style_linebr)

fill(bodyMiddle1, upTrend1, color.new(color.green, 90), fillgaps=false)
fill(bodyMiddle1, downTrend1, color.new(color.red, 90), fillgaps=false)

//End supertrend  7,2.5


lookback = input(13, title = "Lookback") 
filterHigh = input(0.05, title = "Filter High") 
filterLow = input(-0.05, title = "Filter Low") 
price = input(close, "Period")

mma = ta.ema(price * 1000, lookback)
smma = ta.ema(mma, lookback)

impetmma = mma - mma[1]
impetsmma= smma - smma[1]
divma = math.abs(mma - smma)
averimpet = (impetmma + impetsmma) / 2

number = averimpet
pow = 3
result = float(na)

for i = 1 to pow - 1
    if i == 1
        result := number
    result := result * number

tdf = divma * result
ntdf = tdf / ta.highest(math.abs(tdf), lookback * 3)

c = ntdf > filterHigh ? color.green : ntdf < filterLow ? color.red : color.gray
plot(ntdf, linewidth = 2, color = c)

hline(filterHigh, color = color.black)
hline(filterLow, color = color.black)



//HL OTT
lengthott = input.int(2, 'OTT Period', minval=1)
percent = input.float(0.6, 'OTT Optimization Coeff', step=0.1, minval=0)
hllength = input.int(10, 'Highest and Lowest Length', minval=1)
srcott = ta.highest(high, hllength)
srcl = ta.lowest(low, hllength)
highlighting = input(title='Highlighter On/Off ?', defval=true)
mav = input.string(title='Moving Average Type', defval='VAR', options=['SMA', 'EMA', 'WMA', 'DEMA', 'TMA', 'VAR', 'WWMA', 'ZLEMA', 'TSF', 'HULL'])
Var_Func(srcott, lengthott) =>
    valpha = 2 / (lengthott + 1)
    vud1 = srcott > srcott[1] ? srcott - srcott[1] : 0
    vdd1 = srcott < srcott[1] ? srcott[1] - srcott : 0
    vUD = math.sum(vud1, 9)
    vDD = math.sum(vdd1, 9)
    vCMO = nz((vUD - vDD) / (vUD + vDD))
    VAR = 0.0
    VAR := nz(valpha * math.abs(vCMO) * srcott) + (1 - valpha * math.abs(vCMO)) * nz(VAR[1])
    VAR
VAR = Var_Func(srcott, lengthott)
DEMA = 2 * ta.ema(srcott, lengthott) - ta.ema(ta.ema(srcott, lengthott), lengthott)
Wwma_Func(srcott, lengthott) =>
    wwalpha = 1 / lengthott
    WWMA = 0.0
    WWMA := wwalpha * srcott + (1 - wwalpha) * nz(WWMA[1])
    WWMA
WWMA = Wwma_Func(srcott, lengthott)
Zlema_Func(srcott, lengthott) =>
    zxLag = lengthott / 2 == math.round(lengthott / 2) ? lengthott / 2 : (lengthott - 1) / 2
    zxEMAData = srcott + srcott - srcott[zxLag]
    ZLEMA = ta.ema(zxEMAData, lengthott)
    ZLEMA
ZLEMA = Zlema_Func(srcott, lengthott)
Tsf_Func(srcott, lengthott) =>
    lrc = ta.linreg(srcott, lengthott, 0)
    lrc1 = ta.linreg(srcott, lengthott, 1)
    lrs = lrc - lrc1
    TSF = ta.linreg(srcott, lengthott, 0) + lrs
    TSF
TSF = Tsf_Func(srcott, lengthott)
HMA = ta.wma(2 * ta.wma(srcott, lengthott / 2) - ta.wma(srcott, lengthott), math.round(math.sqrt(lengthott)))
Var_Funcl(srcl, lengthott) =>
    valphal = 2 / (lengthott + 1)
    vud1l = srcl > srcl[1] ? srcl - srcl[1] : 0
    vdd1l = srcl < srcl[1] ? srcl[1] - srcl : 0
    vUDl = math.sum(vud1l, 9)
    vDDl = math.sum(vdd1l, 9)
    vCMOl = nz((vUDl - vDDl) / (vUDl + vDDl))
    VARl = 0.0
    VARl := nz(valphal * math.abs(vCMOl) * srcl) + (1 - valphal * math.abs(vCMOl)) * nz(VARl[1])
    VARl
VARl = Var_Funcl(srcl, lengthott)
DEMAl = 2 * ta.ema(srcl, lengthott) - ta.ema(ta.ema(srcl, lengthott), lengthott)
Wwma_Funcl(srcl, lengthott) =>
    wwalphal = 1 / lengthott
    WWMAl = 0.0
    WWMAl := wwalphal * srcl + (1 - wwalphal) * nz(WWMAl[1])
    WWMAl
WWMAl = Wwma_Funcl(srcl, lengthott)
Zlema_Funcl(srcl, lengthott) =>
    zxLagl = lengthott / 2 == math.round(lengthott / 2) ? lengthott / 2 : (lengthott - 1) / 2
    zxEMADatal = srcl + srcl - srcl[zxLagl]
    ZLEMAl = ta.ema(zxEMADatal, lengthott)
    ZLEMAl
ZLEMAl = Zlema_Funcl(srcl, lengthott)
Tsf_Funcl(srcl, lengthott) =>
    lrcl = ta.linreg(srcl, lengthott, 0)
    lrc1l = ta.linreg(srcl, lengthott, 1)
    lrsl = lrcl - lrc1l
    TSFl = ta.linreg(srcl, lengthott, 0) + lrsl
    TSFl
TSFl = Tsf_Funcl(srcl, lengthott)
HMAl = ta.wma(2 * ta.wma(srcl, lengthott / 2) - ta.wma(srcl, lengthott), math.round(math.sqrt(lengthott)))

getMA(srcott, lengthott) =>
    ma = 0.0
    if mav == 'SMA'
        ma := ta.sma(srcott, lengthott)
        ma

    if mav == 'EMA'
        ma := ta.ema(srcott, lengthott)
        ma

    if mav == 'WMA'
        ma := ta.wma(srcott, lengthott)
        ma

    if mav == 'DEMA'
        ma := DEMA
        ma

    if mav == 'TMA'
        ma := ta.sma(ta.sma(srcott, math.ceil(lengthott / 2)), math.floor(lengthott / 2) + 1)
        ma

    if mav == 'VAR'
        ma := VAR
        ma

    if mav == 'WWMA'
        ma := WWMA
        ma

    if mav == 'ZLEMA'
        ma := ZLEMA
        ma

    if mav == 'TSF'
        ma := TSF
        ma

    if mav == 'HULL'
        ma := HMA
        ma
    ma


getMAl(srcl, lengthott) =>
    mal = 0.0
    if mav == 'SMA'
        mal := ta.sma(srcl, lengthott)
        mal

    if mav == 'EMA'
        mal := ta.ema(srcl, lengthott)
        mal

    if mav == 'WMA'
        mal := ta.wma(srcl, lengthott)
        mal

    if mav == 'DEMA'
        mal := DEMAl
        mal

    if mav == 'TMA'
        mal := ta.sma(ta.sma(srcl, math.ceil(lengthott / 2)), math.floor(lengthott / 2) + 1)
        mal

    if mav == 'VAR'
        mal := VARl
        mal

    if mav == 'WWMA'
        mal := WWMAl
        mal

    if mav == 'ZLEMA'
        mal := ZLEMAl
        mal

    if mav == 'TSF'
        mal := TSFl
        mal

    if mav == 'HULL'
        mal := HMAl
        mal
    mal

MAvg = getMA(srcott, lengthott)
fark = MAvg * percent * 0.01
longStop = MAvg - fark
longStopPrev = nz(longStop[1], longStop)
longStop := MAvg > longStopPrev ? math.max(longStop, longStopPrev) : longStop
shortStop = MAvg + fark
shortStopPrev = nz(shortStop[1], shortStop)
shortStop := MAvg < shortStopPrev ? math.min(shortStop, shortStopPrev) : shortStop
dir = 1
dir := nz(dir[1], dir)
dir := dir == -1 and MAvg > shortStopPrev ? 1 : dir == 1 and MAvg < longStopPrev ? -1 : dir
MT = dir == 1 ? longStop : shortStop
HOTT = MAvg > MT ? MT * (200 + percent) / 200 : MT * (200 - percent) / 200
HOTTC = color.blue
MAvgl = getMAl(srcl, lengthott)
farkl = MAvgl * percent * 0.01
longStopl = MAvgl - farkl
longStopPrevl = nz(longStopl[1], longStopl)
longStopl := MAvgl > longStopPrevl ? math.max(longStopl, longStopPrevl) : longStopl
shortStopl = MAvgl + farkl
shortStopPrevl = nz(shortStopl[1], shortStopl)
shortStopl := MAvgl < shortStopPrevl ? math.min(shortStopl, shortStopPrevl) : shortStopl
dirl = 1
dirl := nz(dirl[1], dirl)
dirl := dirl == -1 and MAvgl > shortStopPrevl ? 1 : dirl == 1 and MAvgl < longStopPrevl ? -1 : dirl
MTl = dirl == 1 ? longStopl : shortStopl
LOTT = MAvgl > MTl ? MTl * (200 + percent) / 200 : MTl * (200 - percent) / 200
LOTTC = color.red
HOTTLine = plot(nz(HOTT[2]), title='HOTT', color=color.new(HOTTC, 0), linewidth=2, style=plot.style_line)
LOTTLine = plot(nz(LOTT[2]), title='LOTT', color=color.new(LOTTC, 0), linewidth=2, style=plot.style_line)
FillColor = highlighting ? color.new(#9915FF, 80) : na
fill(HOTTLine, LOTTLine, title='Highligter', color=FillColor)
color1 = close > HOTT[2] ? #00FFFF : close < LOTT[2] ? #FF00FF : na
barcolor(color1)
alertcondition(ta.crossover(close, HOTT[2]), title='Price Crossover Alarm', message='PRICE OVER HOTT - BUY SIGNAL!')
alertcondition(ta.crossunder(close, LOTT[2]), title='Price Crossunder Alarm', message='PRICE UNDER LOTT - SELL SIGNAL!')


//supernova trama line start


lengthtrama=input(45),srctrama = input(close)
ama = 0.
hh = math.max(math.sign(ta.change(ta.highest(lengthtrama))),0)
ll = math.max(math.sign(ta.change(ta.lowest(lengthtrama))*-1),0)
tc = math.pow(ta.sma(hh or ll ? 1 : 0,lengthtrama),2)
ama := nz(ama[1]+tc*(srctrama-ama[1]),srctrama)
plot(ama,"Plot",#ff1100,2)

//trama code end